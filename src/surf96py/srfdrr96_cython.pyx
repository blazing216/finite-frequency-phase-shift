'''Cython wrapper for libsrfdis96.so and libsrfdrr96.so

Changelog:
    5 Apr 2021, Yihe Xu, add log
    5 Apr 2021, Yihe Xu, change ift from 999 to iend+1,
        NL equals mmax, NP equals kmax in 'senker'
        add size of array to 'srfdrr_'
'''
from libc.stdlib cimport malloc, free
import sys
import numpy as np

cdef extern void disp_(
    int* nlayer, int* nperiod,
    int* mmax, float* d, float* a,float* b,float* rho,
    double* twopi, double* one,
    float* betmx,
    double* onea,
    double* cc, double* dc, double* c1, double* cm,
    double* cb, double* c, int* ift,
    int* ifunc,int* igr,float* h,
    float* t,int* iq,int* is1,int* ie,
    int* llw,
    int* iverb,
    int* wvtp,int* md,float* prd1,float* prd2,float* vel1,float* vel2)

cdef extern void __srfdrr96_module_MOD_check_for_water_layer(
    float* b, float* d, int* kw, int* ll, 
    double* dphw, double* dphw0)

# Transform spherical earth to flat earth
#     ifunc   I*4 1 - Love Wave
#                 2 - Rayleigh Wave
#     iflag   I*4 0 - Initialize
#                 1 - Make model  for Love or Rayleigh Wave
cdef extern void __srfdis96_module_MOD_sphere(int *n,
    int* ifunc, int* iflag,
    float* d, float* a, float* b, float *rho,
    float* rtp, float* dtp, float* btp, int* mmax)

cdef extern void get_maximum_and_minimum_velocities_(int* n, float* betmx,
    float* betmn, int* jmn, int* jsol, int* mmax,
    float* a, float* b)

cdef extern void __srfdis96_module_MOD_get_start_value_for_phase_velocity(
    int* n,
    float* betmn, int* jso, int* jmn,
    float* a, float* b, float* ddc,
    double* cc, double* dc, double* c1, double* cm)

cdef extern void __srfdis96_module_MOD_zero_cb_and_c(
    int* n,
    int* kmax, double* cb, double* c)

# TODO: check if nlayer = mmax? if so, we can eliminate a parameter
cdef extern void srfdrr_(int* nlayer, int* nlayer2,
    int* mmax, int* nsph, int* mmax2,
    float* btp, float* dtp,
    float* d, float* a, float* b, float* rho,
    double* xmu, double* xlam,
    int* kw, int* ll, double* dphw, double* dphw0,
    int* igr, float* h,
    int* itst, float* t, float* t1, float* c, float* cn,
    double* t0, double* ugr,
    double* dcda, double* dcdb, double* duda, double* dudb)

#cdef extern void sprayl_(float* om, float* c, float* u,
#    int* mmax2, int* iflag, double* dcda, double* dcdb,
#    float* btp, float* dtp, double* dudb, double* duda)

'''Meanings of variables in srfdis96, srfdrl96, srfdrr96
    Generally, a specific variable may be assigned other values
    in certain cases

    model:
        frequently used:
        mmax        int,            number of layers
        d           float[NL],      thickness of layers
        a           float[NL],      vp
        b           float[NL],      vs
        rho/rho1    float[NL],      density

        btp         float[NL]       not clear, for model flattening
        dtp         float[NL]       not clear, for model flattening
            generated by the subroutine sphere in srfdis96,
            written to the header of dispersion files tmpsrfi.06 (Love) and
            tmpsrfi.07 (Rayleigh)
        
        less used:
        refdep      float           reference depth
            0 for no water layer, >0 for having water layer?

        rarely used:
        title       char*,          title (LINE02)
        iiso        int,            isotropic (0), tra (1), ani(2)
        iunit       int,            kgs(0), no other options
        iflsph      int,            flat model(0), sperical (1)
        idimen      int,            1D(1), 2D(2), 3D(3)
        icnvel      int,            constant velocity(0), var(1)
        qa          float[NL]       Q for vp?
        qs          float[NL]       Q for vs?
        etap        float[NL]       unknown
        etas        float[NL]       unknown
        frefp       float[NL]       reference frequency for P
        frefs       float[NL]       reference frequency for S

    temp file:
        tmpsrfi.17 velocity model, in ascii
            used in srfdis96.f for reading model parameters
        tmpsrfi.03 settings for computing phase/group velocity
            used in srfdis96 to read in settings for compute
            phase and group velocities

            header: 3 integer
                idispl switch for computing Love, 1 on, 0 off
                idispr switch for computing Rayleigh, 1 on, 0 off
                nsph   flat model (0) or spherical (1)
            body:
                subheader 2 int, 2 float, 1 int, 1 float, kmax float
                    kmax number of periods
                    mode highest mode
                    ddc  step in search phase velocity
                    sone unclear
                    igr  0 for phase, 1 for group, 2 for both
                    h    perturbation for group velocity computation
                    t(i), i=1,kmax periods
                subbody 2*mode int
                    is, ie indices for lowest and highest periods 
                        available for each mode
            another body: smae as the one above, if both Rayleigh and
                Love waves are needed to compute

        unclear, has idispl, idispr, nsph
            kmax,mode,ddc,sone,igr,h
            t(i),i=1,kmax
            where kmax is the number of periods,
            mode is the highest mode
            ddc is the step in searching c?
            sone unclear
            igr 0 phase, 1 group, 2 Both
            h pertubation in period for computing group
                velocity later (used in srfdrl96 and srfdrr96)
        tmpsrfi.06 dispersion for Love wave, in binary
            header: model information, 2 int, 4*mmax real, 2 int, 1 real
                2 integer
                    mmax number of layers
                    nsph 0 for flat model, 1 for spherical
                        spherical model should be flattened
                        before computing dispersion or kernels
                mmax real*4
                    btp unclear yet, related to flattening
                mmax real*4
                    dtp unclear yet, related to flattening
                mmax * 4 real*4
                    d(i), a(i), b(i), rho(i), i=1,mmax
                    thickness, vp, vs, density for each layer
                2 integer
                    kmax number of periods
                    igr  0 for phase, 1 for group, 2 for both
                1 real*4
                    h  for pertubating the period for computing
                        group velocity
                        t/(1+h), t/(1-h)

            body: 2 integer(4bytes) 4 real(4bytes)
                1 integer: wvtp/itst 0 for Love, 1 for Rayleigh 
                2 integer: md/iq 1 for fund, >1 for higher modes
                3 real: prd1/t1a period for phase, period/(1+h) for group
                4 real: prd2/t1b 0 for phase, period/(1-h) for group
                5 real: vel1/cc0 phase velocity for period (phase),
                    or period/(1+h) (group)
                6 real: vel2/cc1 0 for phase, phase velocity for
                    period/(1+h) (group)

        tmpsrfi.07 dispersion for Rayleigh wave, in binary
            same as tmpsrfi.06, but for Rayleigh wave
'''

# global parameters for searching for dispersion curves
# It is the default value in CPS330. Normally, it is no
# need to change.
# If you do want to change, remember that small ddc and h
# indicate small search steps, which will increasing 
# the searching time.
default_control_parameters = {'ddc': 0.005,
    'sone':0, 'h':0.005}

def read_cps330_model(model_file):
    with open(model_file, 'r') as mf:
        lines = mf.readlines()
    title = lines[1].strip()
    iiso_options = {'ISOTROPIC':0, 
        'TRANSVERSE ISOTROPIC':1,
        'ANISOTROPIC':2}
    iiso = iiso_options[lines[2].strip().upper()]
    iunit = 0
    iflsph_options = {'FLAT EARTH':0, 'SPHERICAL EARTH':1}
    iflsph = iflsph_options[lines[4].strip().upper()]
    idimen_options = {'1-D':1, '2-D':2, '3-D':3}
    idimen = idimen_options[lines[5].strip().upper()]
    icnvel_options = {'CONSTANT VELOCITY':0, 'VARIABLE VELOCITY':1}
    icnvel = icnvel_options[lines[6].strip().upper()]

    model = np.loadtxt(model_file, skiprows=12)

    return title, iiso, iunit, iflsph, idimen, icnvel, model

def check_water_layer(b):
    if b[0] <= 0.0:
        llw = 2
    else:
        llw = 1
    return llw

def disper(model, periods, iflsph=0, wavetype='rayleigh',
    velocitytype='phase', wave_mode=0):
    '''Compute dispersion curves for Rayleigh/Love phase/group velocity

    c = disper(model, periods, iflsph=0, wavetype='rayleigh',
        velocitytype='phase', wave_mode=0)

    It is basically a translate of the main program srfdis96 in srfdis96.f

    model: an n*4 array (float). The 4 columns are layer thickness, vp, vs, rho.
        Each row corresponds to one layer. The bottom layer should have
        a zero thickness.
    periods: a list of periods (float) at where dispersion curves are
        computed. Maximum length is probably bounded.
    iflsph: integer. If iflsph = 1, spherical flattening is performed
        to the model before compute dispersion.
    wavetype: rayleigh or love
    velocitytype: phase or group
    wave_mode: 0 for fundamental mode, 1+ for higher modes
    '''

    cdef int i

    # check water layer
    # model[:,2] is the shear wave velocity
    cdef int llw = check_water_layer(model[:,2])

    # read in velocity model
    cdef int nsph = iflsph
    cdef int mmax = model.shape[0]
    # cdef int NL = 200
    cdef int NL = mmax
    cdef float* d   = <float*> malloc(NL*sizeof(float))
    cdef float* a   = <float*> malloc(NL*sizeof(float))
    cdef float* b   = <float*> malloc(NL*sizeof(float))
    cdef float* rho = <float*> malloc(NL*sizeof(float))
    cdef float* rtp = <float*> malloc(NL*sizeof(float))
    cdef float* dtp = <float*> malloc(NL*sizeof(float))
    cdef float* btp = <float*> malloc(NL*sizeof(float))

    for i in range(mmax):
        d[i]   = model[i,0] # layer thickness
        a[i]   = model[i,1] # P wave velocity
        b[i]   = model[i,2] # S wave velocity
        rho[i] = model[i,3] # density
        rtp[i] = 0
        dtp[i] = 0
        btp[i] = 0

    # flattening if iflsph = 1
    cdef int tmpint = 0
    cdef int iflag = 0

    if nsph == 1:
        print(('disper is not suitable for spherical earth model'
            ', because spherical correction of phase/group velocity'
            ' needs kernels. use senker for spherical earth model'
            ' instead'), file=sys.stderr)
        __srfdis96_module_MOD_sphere(&NL, &tmpint, &iflag, d, a, b, rho,
            rtp, dtp, btp, &mmax)

    # A quick analysis of velocities of the model
    # to have a reasonable guess for dispersion
    # finding (essentailly root finding)
    cdef float betmx, betmn
    cdef int jmn, jsol

    get_maximum_and_minimum_velocities_(&NL, &betmx,
        &betmn, &jmn, &jsol, &mmax, a, b)

    # set default control paramters for search poles
    cdef float ddc = default_control_parameters['ddc']
    cdef float sone = default_control_parameters['sone']
    cdef float h = default_control_parameters['h']

    # set inputs
    # periods, wave type, velocity type
    # highest mode, 
    cdef int kmax = len(periods)
    # cdef int NP = 512
    cdef int NP = kmax
    cdef float* t = <float*> malloc(NP*sizeof(float))
    for i in range(kmax):
        t[i] = periods[i]
    cdef int ifunc = 2 if wavetype.upper() == 'RAYLEIGH' else 1
    # mode start from 1 (fundamental)
    cdef int mode = wave_mode + 1
    cdef int igr
    if velocitytype.upper() == 'PHASE':
        igr = 0
    elif velocitytype.upper() == 'GROUP':
        igr = 1
    elif velocitytype.upper() == 'BOTH':
        igr = 2
    else:
        igr = 2

    # perform flattening
    iflag = 1
    if nsph == 1:
        __srfdis96_module_MOD_sphere(&NL, &ifunc, &iflag, d, a, b, rho,
            rtp, dtp, btp, &mmax)

    if sone < 0.01:
        sone = 2.0
    cdef double onea = sone

    # first, guess the phase velocity 
    cdef double cc, dc, c1, cm
    __srfdis96_module_MOD_get_start_value_for_phase_velocity(
        &NL,
        &betmn, &jsol, &jmn, a, b,
        &ddc, &cc, &dc, &c1, &cm
    )

    cdef double* c = <double*> malloc(NP*sizeof(double))
    cdef double* cb = <double*> malloc(NP*sizeof(double))

    __srfdis96_module_MOD_zero_cb_and_c(&NP,&kmax,cb,c)

    # ift is the maximum number of periods
    # across different modes and wave types and
    # velocity types
    # Increase ift from 999 to 9999.
    # However it seems irrelevant because ift is
    # assigned to ie for each mode
    # by Yihe 31 Mar 2021
    cdef int ift=999
    # iq, istart, iend might not be needed in
    # this single mode function
    cdef int iq=mode, istart=1, iend=kmax
    ift = iend + 1

    cdef double twopi = 2.*3.141592653589793
    cdef double one = 0.01

    # for print error message only once
    cdef int iverb[2]
    iverb[0] = 0
    iverb[1] = 0

    # output
    cdef int* wvtp = <int*> malloc(NP*sizeof(int))
    cdef int* md   = <int*> malloc(NP*sizeof(int))
    cdef float* prd1 = <float*> malloc(NP*sizeof(float))
    cdef float* prd2 = <float*> malloc(NP*sizeof(float))
    cdef float* vel1 = <float*> malloc(NP*sizeof(float))
    cdef float* vel2 = <float*> malloc(NP*sizeof(float))

    # search for phase velocities
    disp_(&NL,&NP,&mmax,d,a,b,rho,
        &twopi, &one,
        &betmx,
        &onea,
        &cc,&dc,&c1,&cm,cb,c,&ift,
        &ifunc,&igr,&h,
        t,&iq,&istart,&iend,
        &llw,
        iverb,
        wvtp,md,prd1,prd2,vel1,vel2)

    cdef istart_in_c = istart - 1

    vel = []
    for i in range(istart_in_c, iend):
        if igr == 0:
            vel.append(vel1[i])
        else:
            gvel = (1/prd1[i]-1/prd2[i]) / \
                (1/(prd1[i]*vel1[i]) - 1/(prd2[i]*vel2[i]))
            vel.append(gvel)

    free(t)
    free(d) 
    free(a) 
    free(b)
    free(rho)
    free(rtp)
    free(dtp)
    free(btp)
    free(c)
    free(cb)
    free(wvtp)
    free(md)
    free(prd1)
    free(prd2)
    free(vel1)
    free(vel2)

    return np.array(vel)

def senker(model, periods, iflsph=0, wavetype='rayleigh',
    velocitytype='phase', wave_mode=0):
    '''
    Sensitivity kernels of surface waves

    velocitytype == 'phase':
    [vel_phase, ker_dcda, ker_dcdb, ker_dcdh] =
        senker(model, periods, iflsph=0,
        wavetype='rayleigh', velocitytype='phase',
        wave_mode=0)

    velocitytype == 'group':
    [vel_group,
        ker_duda, ker_dudb, ker_dudh] =
        senker(model, periods, iflsph=0,
        wavetype='rayleigh', velocitytype='group',
        wave_mode=0)

    velocitytype == 'both':
    [vel_phase, vel_group,
        ker_dcda, ker_dcdb, ker_dcdh,
        ker_duda, ker_dudb, ker_dudh] =
        senker(model, periods, iflsph=0,
        wavetype='rayleigh', velocitytype='both',
        wave_mode=0)

    vel_phase: phase velocity
    vel_group: group velocity
    ker_*:     sensitivity kernels
    c - phase velocity, u - group velocity
    a - vp, b - vs, h -layer thickness

    Note the kernels is related to other kernels by
    ker_*/thk, thk is thickness of each layer
    '''

    cdef int i

    # check water layer
    cdef int llw = check_water_layer(model[:,2])

    # read in velocity model
    cdef int nsph = iflsph
    cdef int mmax = model.shape[0]
    # cdef int NL = 200
    cdef int NL = mmax
    cdef int NL2 = NL + NL
    cdef float* d   = <float*> malloc(NL*sizeof(float))
    cdef float* a   = <float*> malloc(NL*sizeof(float))
    cdef float* b   = <float*> malloc(NL*sizeof(float))
    cdef float* rho = <float*> malloc(NL*sizeof(float))
    cdef float* rtp = <float*> malloc(NL*sizeof(float))
    cdef float* dtp = <float*> malloc(NL*sizeof(float))
    cdef float* btp = <float*> malloc(NL*sizeof(float))

    for i in range(mmax):
        d[i]   = model[i,0]
        a[i]   = model[i,1]
        b[i]   = model[i,2]
        rho[i] = model[i,3]
        rtp[i] = 0
        dtp[i] = 0
        btp[i] = 0

    # prepare for flattening
    cdef int tmpint = 0
    cdef int iflag = 0
    if nsph == 1:
        __srfdis96_module_MOD_sphere(&NL, &tmpint, &iflag, d, a, b, rho,
            rtp, dtp, btp, &mmax)

    cdef float betmx, betmn
    cdef int jmn, jsol
    
    get_maximum_and_minimum_velocities_(&NL, &betmx,
        &betmn, &jmn, &jsol, &mmax, a, b)

    # set default control paramters for search poles
    cdef float ddc = default_control_parameters['ddc']
    cdef float sone = default_control_parameters['sone']
    cdef float h = default_control_parameters['h']

    # set inputs
    # periods, wave type, velocity type
    # highest mode, 
    cdef int kmax = len(periods)
    # cdef int NP = 512
    cdef int NP = kmax
    cdef float* t = <float*> malloc(NP*sizeof(float))
    for i in range(kmax):
        t[i] = periods[i]
    cdef int ifunc = 2 if wavetype.upper() == 'RAYLEIGH' else 1
    # mode start from 1 (fundamental)
    cdef int mode = wave_mode + 1 
    cdef int igr 
    if velocitytype.upper() == 'PHASE':
        igr = 0
    elif velocitytype.upper() == 'GROUP':
        igr = 1
    elif velocitytype.upper() == 'BOTH':
        igr = 2
    else:
        igr = 2

    # perform flattening
    iflag = 1
    if nsph == 1:
        __srfdis96_module_MOD_sphere(&NL, &ifunc, &iflag, d, a, b, rho,
            rtp, dtp, btp, &mmax)

    if sone < 0.01:
        sone = 2.0 
    cdef double onea = sone

    # first, guess the phase velocity 
    cdef double cc, dc, c1, cm
    __srfdis96_module_MOD_get_start_value_for_phase_velocity(
        &NL,
        &betmn, &jsol, &jmn, a, b, 
        &ddc, &cc, &dc, &c1, &cm
    )

    cdef double* c = <double*> malloc(NP*sizeof(double))
    cdef double* cb = <double*> malloc(NP*sizeof(double))
    __srfdis96_module_MOD_zero_cb_and_c(&NP,&kmax,cb,c)
 
    cdef int ift=999
    # iq, istart, iend might not be needed in
    # this single mode function
    cdef int iq=mode, istart=1, iend=kmax
    ift = iend + 1

    cdef double twopi = 2.*3.141592653589793
    cdef double one = 0.01

    # for print error message only once
    cdef int iverb[2]
    iverb[0] = 0
    iverb[1] = 0

    # output
    cdef int* wvtp = <int*> malloc(NP*sizeof(int))
    cdef int* md   = <int*> malloc(NP*sizeof(int))
    cdef float* prd1 = <float*> malloc(NP*sizeof(float))
    cdef float* prd2 = <float*> malloc(NP*sizeof(float))
    cdef float* vel1 = <float*> malloc(NP*sizeof(float))
    cdef float* vel2 = <float*> malloc(NP*sizeof(float))

    # search for phase velocities
    disp_(&NL,&NP,&mmax,d,a,b,rho,
        &twopi, &one,
        &betmx,
        &onea,
        &cc,&dc,&c1,&cm,cb,c,&ift,
        &ifunc,&igr,&h,
        t,&iq,&istart,&iend,
        &llw,
        iverb,
        wvtp,md,prd1,prd2,vel1,vel2)

    cdef istart_in_c = istart - 1

    if ifunc == 1: # Love
        print("Not implemented yet")
        return None

    # Rayleigh kernels
    cdef int mmax2 = 2 * mmax
    cdef double* xmu = <double*> malloc(NL*sizeof(double))
    cdef double* xlam = <double*> malloc(NL*sizeof(double))
    for i in range(mmax):
        xmu[i] = rho[i] * b[i] * b[i]
        xlam[i] = rho[i] * (a[i]*a[i]-2*b[i]*b[i])

    # check for water layer
    cdef int kw, ll
    cdef double* dphw = <double*> malloc(NL*sizeof(double))
    cdef double dphw0
    if b[0] <= 0.0:
        kw = 1
        ll = kw + 1
        dphw[0] = 0
        dphw[1] = d[0]
        dphw0 = d[0]
    else:
        kw = 0
        ll = kw + 1

    cdef double t0, ugr
    cdef double* dcda = <double*> malloc(NL*2*sizeof(double))
    cdef double* dcdb = <double*> malloc(NL*2*sizeof(double))
    cdef double* dudb = <double*> malloc(NL*2*sizeof(double))
    cdef double* duda = <double*> malloc(NL*2*sizeof(double))
    for i in range(mmax*2):
        dcda[i] = 0
        dcdb[i] = 0
        duda[i] = 0
        dudb[i] = 0

    cdef int itst
    cdef float srfdrr_t, srfdrr_t1, srfdrr_c, srfdrr_cn
    cdef int j
    vel_phase = []
    vel_group = []
    ker_dcda = []
    ker_dcdb = []
    ker_dcdh = []
    ker_duda = []
    ker_dudb = []
    ker_dudh = []
    for i in range(istart_in_c,iend):
        itst = wvtp[i]
        srfdrr_t = prd1[i]
        srfdrr_t1 = prd2[i]
        srfdrr_c = vel1[i]
        srfdrr_cn = vel2[i]
        srfdrr_(&NL, &NL2,
            &mmax, &nsph, &mmax2,
            btp, dtp, d, a, b, rho,
            xmu, xlam,
            &kw, &ll, dphw, &dphw0,
            &igr, &h,
            &itst,&srfdrr_t,&srfdrr_t1,&srfdrr_c,&srfdrr_cn,
            &t0,&ugr,dcda,dcdb,duda,dudb
        )
        vel_phase.append(srfdrr_c)
        vel_group.append(ugr)
        ker_dcda.append([dcda[j] for j in range(mmax)])
        ker_dcdb.append([dcdb[j] for j in range(mmax)])
        ker_dcdh.append([dcdb[j] for j in range(mmax,mmax2)])
        ker_duda.append([duda[j] for j in range(mmax)])
        ker_dudb.append([dudb[j] for j in range(mmax)])
        ker_dudh.append([dudb[j] for j in range(mmax,mmax2)])

    if igr == 0:
        output = [np.array(vel_phase), np.array(ker_dcda),
                np.array(ker_dcdb), np.array(ker_dcdh)]
    elif igr == 1:
        output = [np.array(vel_group),
            np.array(ker_duda), np.array(ker_dudb), np.array(ker_dudh)]
    elif igr >= 2:
        output = [np.array(vel_phase), np.array(vel_group),
            np.array(ker_dcda), np.array(ker_dcdb), np.array(ker_dcdh),
            np.array(ker_duda), np.array(ker_dudb), np.array(ker_dudh)]

    free(t)
    free(d) 
    free(a) 
    free(b)
    free(rho)
    free(rtp)
    free(dtp)
    free(btp)
    free(c)
    free(cb)
    free(wvtp)
    free(md)
    free(prd1)
    free(prd2)
    free(vel1)
    free(vel2)

    free(xmu)
    free(xlam)
    free(dphw)
    free(dcda)
    free(dcdb)
    free(dudb)
    free(duda)

    return tuple(output)


def main(model_file, wavetype='rayleigh',
    velocitytype='phase', wave_mode=0, periods=[10]):

    title, iiso, iunit, iflsph, idimen, icnvel, model = \
        read_cps330_model(model_file)

    output1 = (title, iiso, iunit, iflsph, idimen, icnvel, model)
    # print('output1')

    cdef int llw = check_water_layer(model[:,2])

    # velocity model
    cdef int nsph = iflsph
    cdef int mmax = model.shape[0]
    cdef int NL = mmax
    cdef int NL2 = NL + NL
    cdef float* d   = <float*> malloc(NL*sizeof(float))
    cdef float* a   = <float*> malloc(NL*sizeof(float))
    cdef float* b   = <float*> malloc(NL*sizeof(float))
    cdef float* rho = <float*> malloc(NL*sizeof(float))
    cdef float* rtp = <float*> malloc(NL*sizeof(float))
    cdef float* dtp = <float*> malloc(NL*sizeof(float))
    cdef float* btp = <float*> malloc(NL*sizeof(float))

    cdef int i

    for i in range(mmax):
        d[i]   = model[i,0]
        a[i]   = model[i,1]
        b[i]   = model[i,2]
        rho[i] = model[i,3]
        rtp[i] = 0
        dtp[i] = 0
        btp[i] = 0
    # print(mmax)

    cdef int tmpint = 0
    cdef int iflag = 0
    if nsph == 1:
        __srfdis96_module_MOD_sphere(&NL, &tmpint, &iflag, d, a, b, rho,
            rtp, dtp, btp, &mmax)

    cdef float betmx, betmn
    cdef int jmn, jsol

    # unsolved segmentation fault: 11 in calling
    # get_maximum_and_minimum_velocities_
    # solved because of return type not specified
    # rewrite in cython
    get_maximum_and_minimum_velocities_(&NL, &betmx,
        &betmn, &jmn, &jsol, &mmax, a, b)

    # print('after get velocities')
    # __srfdis96_module_MOD_test(&jmn, d)



    # set default control paramters
    cdef float ddc = default_control_parameters['ddc']
    cdef float sone = default_control_parameters['sone']
    cdef float h = default_control_parameters['h']

    # set inputs
    # periods, wave type, velocity type
    # highest mode, 
    cdef int kmax = len(periods)
    # cdef int NP = 512
    cdef int NP = kmax
    cdef float* t = <float*> malloc(NP*sizeof(float))
    for i in range(kmax):
        t[i] = periods[i]
    cdef int ifunc = 2 if wavetype.upper() == 'RAYLEIGH' else 1
    # mode start from 1 (fundamental)
    cdef int mode = wave_mode + 1
    cdef int igr
    if velocitytype.upper() == 'PHASE':
        igr = 0
    elif velocitytype.upper() == 'GROUP':
        igr = 1
    elif velocitytype.upper() == 'BOTH':
        igr = 2
    else:
        igr = 2

    iflag = 1
    if nsph == 1:
        __srfdis96_module_MOD_sphere(&NL, &ifunc, &iflag, d, a, b, rho,
            rtp, dtp, btp, &mmax)

    output2 = (llw,mmax,nsph,
        ifunc,igr,mode,jmn,jsol,betmx,betmn)
    #print('output2')

    if sone < 0.01:
        sone = 2.0 
    cdef double onea = sone

    cdef double cc, dc, c1, cm
    __srfdis96_module_MOD_get_start_value_for_phase_velocity(
        &NL,
        &betmn, &jsol, &jmn, a, b, 
        &ddc, &cc, &dc, &c1, &cm
    )
    #print('guess')
    cdef double* c = <double*> malloc(NP*sizeof(double))
    cdef double* cb = <double*> malloc(NP*sizeof(double))
    #for i in range(NP):
    #    c[i] = 10
    #    cb[i] = 233

    # cdef float* c = <float*> malloc(NP*sizeof(float))
    # cdef float* cb = <float*> malloc(NP*sizeof(float))
    # print(kmax, NP)
    # for i in range(NP):
    #     print(c[i])
    __srfdis96_module_MOD_zero_cb_and_c(&NP,&kmax,cb,c)
    #print('zero')

    cdef int ift=999
    # iq, istart, iend might not be needed in
    # this single mode function
    cdef int iq=mode, istart=1, iend=kmax
    ift = iend + 1

    cdef double twopi = 2.*3.141592653589793
    cdef double one = 0.01

    # for print error message only once
    cdef int iverb[2]
    iverb[0] = 0
    iverb[1] = 0

    output3 = []
    #print('output3')

    # output
    cdef int* wvtp = <int*> malloc(NP*sizeof(int))
    cdef int* md   = <int*> malloc(NP*sizeof(int))
    cdef float* prd1 = <float*> malloc(NP*sizeof(float))
    cdef float* prd2 = <float*> malloc(NP*sizeof(float))
    cdef float* vel1 = <float*> malloc(NP*sizeof(float))
    cdef float* vel2 = <float*> malloc(NP*sizeof(float))


    disp_(&NL,&NP,&mmax,d,a,b,rho,
        &twopi, &one,
        &betmx,
        &onea,
        &cc,&dc,&c1,&cm,cb,c,&ift,
        &ifunc,&igr,&h,
        t,&iq,&istart,&iend,
        &llw,
        iverb,
        wvtp,md,prd1,prd2,vel1,vel2)

    cdef istart_in_c = istart - 1

    output4 = [[wvtp[i] for i in range(istart_in_c,iend)],
        [md[i] for i in range(istart_in_c,iend)],
        [prd1[i] for i in range(istart_in_c,iend)],
        [prd2[i] for i in range(istart_in_c,iend)],
        [vel1[i] for i in range(istart_in_c,iend)],
        [vel2[i] for i in range(istart_in_c,iend)]]

    #print('output4')

    if ifunc == 1: # Love
        print("Not implemented yet")
        output5 = []

    # for srfdrr
    cdef int mmax2 = 2 * mmax
    cdef double* xmu = <double*> malloc(NL*sizeof(double))
    cdef double* xlam = <double*> malloc(NL*sizeof(double))
    for i in range(mmax):
        xmu[i] = rho[i] * b[i] * b[i]
        xlam[i] = rho[i] * (a[i]*a[i]-2*b[i]*b[i])

    # check for water layer
    cdef int kw, ll
    cdef double* dphw = <double*> malloc(NL*sizeof(double))
    cdef double dphw0
    if b[0] <= 0.0:
        kw = 1
        ll = kw + 1
        dphw[0] = 0
        dphw[1] = d[0]
        dphw0 = d[0]
    else:
        kw = 0
        ll = kw + 1

    #print('check water layer again')

    cdef double t0, ugr
    cdef double* dcda = <double*> malloc(NL*2*sizeof(double))
    cdef double* dcdb = <double*> malloc(NL*2*sizeof(double))
    cdef double* dudb = <double*> malloc(NL*2*sizeof(double))
    cdef double* duda = <double*> malloc(NL*2*sizeof(double))
    for i in range(mmax*2):
        dcda[i] = 0
        dcdb[i] = 0
        duda[i] = 0
        dudb[i] = 0

    cdef int itst
    cdef float srfdrr_t, srfdrr_t1, srfdrr_c, srfdrr_cn
    cdef int j
    vel_phase = []
    vel_group = []
    ker_dcda = []
    ker_dcdb = []
    ker_dcdh = []
    ker_duda = []
    ker_dudb = []
    ker_dudh = []
    for i in range(istart_in_c,iend):
        itst = wvtp[i]
        srfdrr_t = prd1[i]
        srfdrr_t1 = prd2[i]
        srfdrr_c = vel1[i]
        srfdrr_cn = vel2[i]
        #print('before srfdrr_, i=', i)
        srfdrr_(&NL,&NL2,
            &mmax, &nsph, &mmax2,
            btp, dtp, d, a, b, rho,
            xmu, xlam,
            &kw, &ll, dphw, &dphw0,
            &igr, &h,
            &itst,&srfdrr_t,&srfdrr_t1,&srfdrr_c,&srfdrr_cn,
            &t0,&ugr,dcda,dcdb,duda,dudb
        )
        #print('after srfdrr_, i=', i)
        vel_phase.append(srfdrr_c)
        vel_group.append(ugr)
        ker_dcda.append([dcda[j] for j in range(mmax)])
        ker_dcdb.append([dcdb[j] for j in range(mmax)])
        ker_dcdh.append([dcdb[j] for j in range(mmax,mmax2)])
        ker_duda.append([duda[j] for j in range(mmax)])
        ker_dudb.append([dudb[j] for j in range(mmax)])
        ker_dudh.append([dudb[j] for j in range(mmax,mmax2)])

    output5 = [vel_phase, vel_group,
        ker_dcda, ker_dcdb, ker_dcdh,
        ker_duda, ker_dudb, ker_dudh]

    free(t)
    free(d) 
    free(a) 
    free(b)
    free(rho)
    free(rtp)
    free(dtp)
    free(btp)
    free(c)
    free(cb)
    free(wvtp)
    free(md)
    free(prd1)
    free(prd2)
    free(vel1)
    free(vel2)

    free(xmu)
    free(xlam)
    free(dphw)
    free(dcda)
    free(dcdb)
    free(dudb)
    free(duda)

    return output1, output2, output3, output4, output5

def compute_fundamental_Rayleigh_phase(periods,
        thk, vp, vs, rho):
    cdef int iiso, iunit, iflsph, idimen, icnvel
    cdef int mmax
    cdef float *d
    cdef float *a
    cdef float *b
    cdef float *rho1
    cdef float *qa
    cdef float *qb
    cdef float *etap
    cdef float *etas
    cdef float *frefp
    cdef float *frefs
    cdef float refdep
    cdef int idispl, idispr, nsph
    cdef int ifunc, kmax, mode, igr, iq, is1, ie, llw
    cdef float ddc, sone, h
    cdef float *t
    cdef float *rtp
    cdef float *dtp
    cdef float *btp
    cdef int *iverb
    cdef int *wvtp
    cdef int *md
    cdef float *prd1
    cdef float *prd2
    cdef float *vel1
    cdef float *vel2

    #cdef char *title = <char*> malloc(81 * sizeof(char))
    #cdef char *mname
    cdef str title, mname

    cdef int NL=200, NP=512
    cdef int i

    iiso = 0
    iunit = 0
    iflsph = 0
    idimen = 1
    icnvel = 0
    igr = 0 # phase
    mode = 1 # mode(funda 1, higher >1)
    idispl = 0
    idispr = 1 # Rayleigh
    nsph = 0
    ifunc = 2 # Rayleigh

    # periods = 1.0/freqs
    kmax = len(periods)
    iq = 1 #
    is1 = 1
    ie = kmax

    iverb = <int*> malloc(2 * sizeof(int))
    iverb[0] = 0
    iverb[1] = 0

    t = <float*> malloc(NP * sizeof(float))
    for i in range(kmax):
        t[i] = periods[i]

    # print(periods)
    # print(len(periods))

    d = <float*> malloc(NL * sizeof(float))
    a = <float*> malloc(NL * sizeof(float))
    b = <float*> malloc(NL * sizeof(float))
    rho1 = <float*> malloc(NL * sizeof(float))
    qa = <float*> malloc(NL * sizeof(float))
    qb = <float*> malloc(NL * sizeof(float))
    etap = <float*> malloc(NL * sizeof(float))
    etas = <float*> malloc(NL * sizeof(float))
    frefp = <float*> malloc(NL * sizeof(float))
    frefs = <float*> malloc(NL * sizeof(float))
    rtp = <float*> malloc(NL * sizeof(float))
    dtp = <float*> malloc(NL * sizeof(float))
    btp = <float*> malloc(NL * sizeof(float))
    
    mmax = len(thk)
    
    for i in range(mmax):
        d[i] = thk[i]
        a[i] = vp[i]
        b[i] = vs[i]
        rho1[i] = rho[i]
        frefp[i] = 1.0
        frefs[i] = 1.0
        qa[i] = 0
        qa[i] = 0
        etap[i] = 0
        etas[i] = 0
    refdep = 0.0
    llw = 1

    ddc = 0.005
    sone = 0
    h = 0.005
    llw = 1
    
    wvtp = <int*> malloc(NP * sizeof(int))
    md = <int*> malloc(NP * sizeof(int))
    prd1 = <float*> malloc(NP * sizeof(float))
    prd2 = <float*> malloc(NP * sizeof(float))
    vel1 = <float*> malloc(NP * sizeof(float))
    vel2 = <float*> malloc(NP * sizeof(float))

    # disp_(
    #     &mmax, d, a, b, rho1,
    #     &nsph,
    #     &ifunc, &kmax, &ddc, &sone, &igr, &h,
    #     t, &iq, &is1, &ie,
    #     rtp, dtp, btp, &llw,
    #     iverb,
    #     wvtp, md, prd1, prd2, vel1, vel2)

    # for i in range(kmax):
    #     print(wvtp[i], md[i], prd1[i],
    #         prd2[i], vel1[i], vel2[i])
    ret = tuple([np.array([prd1[i] for i in range(kmax)]),
        np.array([vel1[i] for i in range(kmax)])])

    free(d)
    free(a)
    free(b)
    free(rho1)
    free(qa)
    free(qb)
    free(etap)
    free(etas)
    free(frefp)
    free(frefs)
    free(rtp)
    free(dtp)
    free(btp)

    free(wvtp)
    free(md)
    free(prd1)
    free(prd2)
    free(vel1)
    free(vel2)
    # free(mname)

    return ret

def compute_fundamental_Rayleigh_phase_kernel(period,
        thk, vp, vs, rho):
    
    cdef int mmax, nsph, mmax2, NL=200
    cdef float *btp
    cdef float *dtp
    cdef float *d
    cdef float *a
    cdef float *b
    cdef float *rho1
    cdef double *xmu
    cdef double *xlam
    cdef int kw, ll
    cdef double *dphw
    cdef double dphw0
    cdef int igr, itst
    cdef float h, t, t1, c, cn
    cdef double t0, ugr
    cdef double *dcda
    cdef double *dcdb
    cdef double *duda
    cdef double *dudb

    cdef int i

    igr = 0 # phase velocity, 1 for group
    itst = 1 # Rayleigh, 0 for Love
    mmax = len(thk)
    mmax2 = 2 * mmax
    nsph = 0 # flat earth
    # h = 

    btp = <float*> malloc(NL*sizeof(float))
    dtp = <float*> malloc(NL*sizeof(float))
    d = <float*> malloc(NL*sizeof(float))
    a = <float*> malloc(NL*sizeof(float))
    b = <float*> malloc(NL*sizeof(float))
    rho1 = <float*> malloc(NL*sizeof(float))
    xmu = <double*> malloc(NL*sizeof(double))
    xlam = <double*> malloc(NL*sizeof(double))
    dphw = <double*> malloc(NL*sizeof(double))

    # initialize the derivatives array for output
    # dc/dvp = dcda[0:NL]
    # dc/dvs = dcdb[0:NL]
    # dc/dh  = dcdb[NL:(NL*2)]
    # du/dvp = duda[0:NL]
    # du/dvs = dudb[0:NL]
    # du/dh  = dudb[NL:(NL*2)]
    dcda = <double*> malloc(NL*2*sizeof(double))
    dcdb = <double*> malloc(NL*2*sizeof(double))
    dudb = <double*> malloc(NL*2*sizeof(double))
    duda = <double*> malloc(NL*2*sizeof(double))

    for i in range(mmax):
        d[i] = thk[i]
        a[i] = vp[i]
        b[i] = vs[i]
        rho1[i] = rho[i]
        xmu[i] = rho1[i] * b[i] * b[i]
        xlam[i] = rho1[i] * (a[i]*a[i] - 2*b[i]*b[i])
    
    __srfdrr96_module_MOD_check_for_water_layer(
        b, d, &kw, &ll, dphw, &dphw0
    )

    # btp, dtp = 

    
    # srfdrr_(&mmax, &nsph, &mmax2,
    #     btp, dtp,
    #     d, a, b, rho, 
    #     xmu, xlam,
    #     &kw, &ll, dphw, &dphw0,
    #     &igr, &h,
    #     &itst, &t, &t1, &c, &cn,
    #     &t0, &ugr, 
    #     dcda, dcdb, duda, dudb)

    ret = tuple([[d[i] for i in range(mmax)],
        [dcda[i] for i in range(mmax)],
        [dcdb[i] for i in range(mmax)],
        [dcdb[i+mmax] for i in range(mmax)]])

    free(btp)
    free(dtp)
    free(d)
    free(a)
    free(b)
    free(rho1)
    free(xmu) 
    free(xlam)
    free(dphw)
    free(dcda)
    free(dcdb)
    free(duda)
    free(dudb)

    return ret



